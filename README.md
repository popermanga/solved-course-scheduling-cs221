Download Link: https://assignmentchef.com/product/solved-course-scheduling-cs221
<br>
<ol class="problem alert">

 <li>There will be a lot of reading in this assignment. Be patient. It’s worth your time! &#x1f642;</li>

 <li><strong>Start early</strong>. <a href="https://piazza.com/class/ir01sqg5rohnt">Ask questions</a>. Have fun.</li>

</ol>

<img decoding="async" alt="calendar" data-src="calendar.jpg" class="float-right lazyload" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">

 <noscript>

  <img decoding="async" class="float-right" src="calendar.jpg" alt="calendar">

 </noscript>

What courses should you take in a given quarter? Answering this question requires balancing your interests, satisfying prerequisite chains, graduation requirements, availability of courses; this can be a complex tedious process. In this assignment, you will write a program that does automatic course scheduling for you based on your preferences and constraints. The program will cast the course scheduling problem (CSP) as a constraint satisfaction problem (CSP) and then use backtracking search to solve that CSP to give you your optimal course schedule.

You will first get yourself familiar with CSP by doing warmup exercises in Problem 0. In Problem 1, you will implement two of the three heuristics you learned from the lectures that will make CSP solving much faster. In problem 2, you will add a helper function to reduce <span id="MathJax-Element-1-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-1" class="math"><span id="MathJax-Span-2" class="mrow"><span id="MathJax-Span-3" class="mi">n</span></span></span></span>-ary factors to unary and binary factors. Lastly, in Problem 3, you will create the course scheduling CSP and solve it using the code from previous parts.

<ol class="problem">

 <li id="0a" class="writeup">[4 points] Let’s create a CSP. Suppose you have <span id="MathJax-Element-2-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-4" class="math"><span id="MathJax-Span-5" class="mrow"><span id="MathJax-Span-6" class="mi">n</span></span></span></span> light bulbs, where each light bulb <span id="MathJax-Element-3-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-7" class="math"><span id="MathJax-Span-8" class="mrow"><span id="MathJax-Span-9" class="mi">i</span><span id="MathJax-Span-10" class="mo">=</span><span id="MathJax-Span-11" class="mn">1</span><span id="MathJax-Span-12" class="mo">,</span><span id="MathJax-Span-13" class="mo">…</span><span id="MathJax-Span-14" class="mo">,</span><span id="MathJax-Span-15" class="mi">n</span></span></span></span> is initially off. You also have <span id="MathJax-Element-4-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-16" class="math"><span id="MathJax-Span-17" class="mrow"><span id="MathJax-Span-18" class="mi">m</span></span></span></span> buttons which control the lights. For each button <span id="MathJax-Element-5-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-19" class="math"><span id="MathJax-Span-20" class="mrow"><span id="MathJax-Span-21" class="mi">j</span><span id="MathJax-Span-22" class="mo">=</span><span id="MathJax-Span-23" class="mn">1</span><span id="MathJax-Span-24" class="mo">,</span><span id="MathJax-Span-25" class="mo">…</span><span id="MathJax-Span-26" class="mo">,</span><span id="MathJax-Span-27" class="mi">m</span></span></span></span>, we know the subset <span id="MathJax-Element-6-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-28" class="math"><span id="MathJax-Span-29" class="mrow"><span id="MathJax-Span-30" class="msubsup"><span id="MathJax-Span-31" class="mi">T</span><span id="MathJax-Span-32" class="mi">j</span></span><span id="MathJax-Span-33" class="mo">⊆</span><span id="MathJax-Span-34" class="mo">{</span><span id="MathJax-Span-35" class="mn">1</span><span id="MathJax-Span-36" class="mo">,</span><span id="MathJax-Span-37" class="mo">…</span><span id="MathJax-Span-38" class="mo">,</span><span id="MathJax-Span-39" class="mi">n</span><span id="MathJax-Span-40" class="mo">}</span></span></span></span> of light bulbs that it controls. When button <span id="MathJax-Element-7-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-41" class="math"><span id="MathJax-Span-42" class="mrow"><span id="MathJax-Span-43" class="mi">j</span></span></span></span> is pressed, it toggles the state of each light bulb in <span id="MathJax-Element-8-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-44" class="math"><span id="MathJax-Span-45" class="mrow"><span id="MathJax-Span-46" class="msubsup"><span id="MathJax-Span-47" class="mi">T</span><span id="MathJax-Span-48" class="mi">j</span></span></span></span></span> (For example, if <span id="MathJax-Element-9-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-49" class="math"><span id="MathJax-Span-50" class="mrow"><span id="MathJax-Span-51" class="mn">3</span><span id="MathJax-Span-52" class="mo">∈</span><span id="MathJax-Span-53" class="msubsup"><span id="MathJax-Span-54" class="mi">T</span><span id="MathJax-Span-55" class="mi">j</span></span></span></span></span> and light bulb 3 is off, then after the button is pressed, light bulb 3 will be on, and vice versa).Your goal is to turn on all the light bulbs by pressing a subset of the buttons. Construct a CSP to solve this problem. Your CSP should have <span id="MathJax-Element-10-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-56" class="math"><span id="MathJax-Span-57" class="mrow"><span id="MathJax-Span-58" class="mi">m</span></span></span></span> variables and <span id="MathJax-Element-11-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-59" class="math"><span id="MathJax-Span-60" class="mrow"><span id="MathJax-Span-61" class="mi">n</span></span></span></span> constraints. <em>For this problem only</em>, you can use <span id="MathJax-Element-12-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-62" class="math"><span id="MathJax-Span-63" class="mrow"><span id="MathJax-Span-64" class="mi">n</span></span></span></span>-ary constraints. Describe your CSP precisely and concisely. You need to specify the variables with their domain, and the constraints with their scope and expression. Make sure to include <span id="MathJax-Element-13-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-65" class="math"><span id="MathJax-Span-66" class="mrow"><span id="MathJax-Span-67" class="msubsup"><span id="MathJax-Span-68" class="mi">T</span><span id="MathJax-Span-69" class="mi">j</span></span></span></span></span> in your answer.</li>

 <li id="0b" class="writeup">[4 points] Let’s consider a simple CSP with 3 variables and 2 binary factors:<img decoding="async" alt="0a - fancy CSP" data-src="0-a.png" class="lazyload" src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">

  <noscript>

   <img decoding="async" src="0-a.png" alt="0a - fancy CSP">

  </noscript>where <span id="MathJax-Element-14-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-70" class="math"><span id="MathJax-Span-71" class="mrow"><span id="MathJax-Span-72" class="msubsup"><span id="MathJax-Span-73" class="mi">X</span><span id="MathJax-Span-74" class="mn">1</span></span><span id="MathJax-Span-75" class="mo">,</span><span id="MathJax-Span-76" class="msubsup"><span id="MathJax-Span-77" class="mi">X</span><span id="MathJax-Span-78" class="mn">2</span></span><span id="MathJax-Span-79" class="mo">,</span><span id="MathJax-Span-80" class="msubsup"><span id="MathJax-Span-81" class="mi">X</span><span id="MathJax-Span-82" class="mn">3</span></span><span id="MathJax-Span-83" class="mo">∈</span><span id="MathJax-Span-84" class="mo">{</span><span id="MathJax-Span-85" class="mn">0</span><span id="MathJax-Span-86" class="mo">,</span><span id="MathJax-Span-87" class="mn">1</span><span id="MathJax-Span-88" class="mo">}</span></span></span></span> and <span id="MathJax-Element-15-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-89" class="math"><span id="MathJax-Span-90" class="mrow"><span id="MathJax-Span-91" class="msubsup"><span id="MathJax-Span-92" class="mi">t</span><span id="MathJax-Span-93" class="mn">1</span></span><span id="MathJax-Span-94" class="mo">,</span><span id="MathJax-Span-95" class="msubsup"><span id="MathJax-Span-96" class="mi">t</span><span id="MathJax-Span-97" class="mn">2</span></span></span></span></span> are <a href="https://en.wikipedia.org/wiki/Exclusive_or">XOR</a> functions (that is <span id="MathJax-Element-16-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-98" class="math"><span id="MathJax-Span-99" class="mrow"><span id="MathJax-Span-100" class="msubsup"><span id="MathJax-Span-101" class="mi">t</span><span id="MathJax-Span-102" class="mn">1</span></span><span id="MathJax-Span-103" class="mo">(</span><span id="MathJax-Span-104" class="mi">X</span><span id="MathJax-Span-105" class="mo">)</span><span id="MathJax-Span-106" class="mo">=</span><span id="MathJax-Span-107" class="msubsup"><span id="MathJax-Span-108" class="mi">x</span><span id="MathJax-Span-109" class="mn">1</span></span><span id="MathJax-Span-110" class="mo">⨁</span><span id="MathJax-Span-111" class="msubsup"><span id="MathJax-Span-112" class="mi">x</span><span id="MathJax-Span-113" class="mn">2</span></span></span></span></span> and <span id="MathJax-Element-17-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-114" class="math"><span id="MathJax-Span-115" class="mrow"><span id="MathJax-Span-116" class="msubsup"><span id="MathJax-Span-117" class="mi">t</span><span id="MathJax-Span-118" class="mn">2</span></span><span id="MathJax-Span-119" class="mo">(</span><span id="MathJax-Span-120" class="mi">X</span><span id="MathJax-Span-121" class="mo">)</span><span id="MathJax-Span-122" class="mo">=</span><span id="MathJax-Span-123" class="msubsup"><span id="MathJax-Span-124" class="mi">x</span><span id="MathJax-Span-125" class="mn">2</span></span><span id="MathJax-Span-126" class="mo">⨁</span><span id="MathJax-Span-127" class="msubsup"><span id="MathJax-Span-128" class="mi">x</span><span id="MathJax-Span-129" class="mn">3</span></span></span></span></span>).

  <ol>

   <li>How many consistent assignments are there for this CSP?</li>

   <li>To see why variable ordering is important, let’s use backtracking search to solve the CSP <em>without using any heuristics (MCV, LCV, AC-3) or lookahead</em>. How many times will <code>backtrack()</code> be called to get all consistent assignments if we use the fixed ordering <span id="MathJax-Element-18-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-130" class="math"><span id="MathJax-Span-131" class="mrow"><span id="MathJax-Span-132" class="msubsup"><span id="MathJax-Span-133" class="mi">X</span><span id="MathJax-Span-134" class="mn">1</span></span><span id="MathJax-Span-135" class="mo">,</span><span id="MathJax-Span-136" class="msubsup"><span id="MathJax-Span-137" class="mi">X</span><span id="MathJax-Span-138" class="mn">3</span></span><span id="MathJax-Span-139" class="mo">,</span><span id="MathJax-Span-140" class="msubsup"><span id="MathJax-Span-141" class="mi">X</span><span id="MathJax-Span-142" class="mn">2</span></span></span></span></span>? Draw the call stack for <code>backtrack()</code>. (You should use the Backtrack algorithm from the slides. The initial arguments are <span id="MathJax-Element-19-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-143" class="math"><span id="MathJax-Span-144" class="mrow"><span id="MathJax-Span-145" class="mi">x</span><span id="MathJax-Span-146" class="mo">=</span><span id="MathJax-Span-147" class="mi">∅</span></span></span></span>, <span id="MathJax-Element-20-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-148" class="math"><span id="MathJax-Span-149" class="mrow"><span id="MathJax-Span-150" class="mi">w</span><span id="MathJax-Span-151" class="mo">=</span><span id="MathJax-Span-152" class="mn">1</span></span></span></span>, and the original Domain.)In the code, this will be <code>BacktrackingSearch.numOperations</code>.</li>

   <li>To see why lookahead can be useful, let’s do it again with the ordering <span id="MathJax-Element-21-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-153" class="math"><span id="MathJax-Span-154" class="mrow"><span id="MathJax-Span-155" class="msubsup"><span id="MathJax-Span-156" class="mi">X</span><span id="MathJax-Span-157" class="mn">1</span></span><span id="MathJax-Span-158" class="mo">,</span><span id="MathJax-Span-159" class="msubsup"><span id="MathJax-Span-160" class="mi">X</span><span id="MathJax-Span-161" class="mn">3</span></span><span id="MathJax-Span-162" class="mo">,</span><span id="MathJax-Span-163" class="msubsup"><span id="MathJax-Span-164" class="mi">X</span><span id="MathJax-Span-165" class="mn">2</span></span></span></span></span> and AC-3. How many times will Backtrack be called to get all consistent assignments? Draw the call stack for <code>backtrack()</code>.</li>

  </ol></li>

 <li class="code">Now let’s consider a general case: given a factor graph with <span id="MathJax-Element-22-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-166" class="math"><span id="MathJax-Span-167" class="mrow"><span id="MathJax-Span-168" class="mi">n</span></span></span></span> variables <span id="MathJax-Element-23-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-169" class="math"><span id="MathJax-Span-170" class="mrow"><span id="MathJax-Span-171" class="msubsup"><span id="MathJax-Span-172" class="mi">X</span><span id="MathJax-Span-173" class="mn">1</span></span><span id="MathJax-Span-174" class="mo">,</span><span id="MathJax-Span-175" class="mo">.</span><span id="MathJax-Span-176" class="mo">.</span><span id="MathJax-Span-177" class="mo">.</span><span id="MathJax-Span-178" class="mo">,</span><span id="MathJax-Span-179" class="msubsup"><span id="MathJax-Span-180" class="mi">X</span><span id="MathJax-Span-181" class="mi">n</span></span></span></span></span> and <span id="MathJax-Element-24-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-182" class="math"><span id="MathJax-Span-183" class="mrow"><span id="MathJax-Span-184" class="mi">n</span><span id="MathJax-Span-185" class="mo">−</span><span id="MathJax-Span-186" class="mn">1</span></span></span></span> binary factors <span id="MathJax-Element-25-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-187" class="math"><span id="MathJax-Span-188" class="mrow"><span id="MathJax-Span-189" class="msubsup"><span id="MathJax-Span-190" class="mi">t</span><span id="MathJax-Span-191" class="mn">1</span></span><span id="MathJax-Span-192" class="mo">,</span><span id="MathJax-Span-193" class="mo">.</span><span id="MathJax-Span-194" class="mo">.</span><span id="MathJax-Span-195" class="mo">.</span><span id="MathJax-Span-196" class="mo">,</span><span id="MathJax-Span-197" class="msubsup"><span id="MathJax-Span-198" class="mi">t</span><span id="MathJax-Span-199" class="texatom"><span id="MathJax-Span-200" class="mrow"><span id="MathJax-Span-201" class="mi">n</span><span id="MathJax-Span-202" class="mo">−</span><span id="MathJax-Span-203" class="mn">1</span></span></span></span></span></span></span> where <span id="MathJax-Element-26-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-204" class="math"><span id="MathJax-Span-205" class="mrow"><span id="MathJax-Span-206" class="msubsup"><span id="MathJax-Span-207" class="mi">X</span><span id="MathJax-Span-208" class="mi">i</span></span><span id="MathJax-Span-209" class="mo">∈</span><span id="MathJax-Span-210" class="mo">{</span><span id="MathJax-Span-211" class="mn">0</span><span id="MathJax-Span-212" class="mo">,</span><span id="MathJax-Span-213" class="mn">1</span><span id="MathJax-Span-214" class="mo">}</span></span></span></span> and <span id="MathJax-Element-27-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-215" class="math"><span id="MathJax-Span-216" class="mrow"><span id="MathJax-Span-217" class="msubsup"><span id="MathJax-Span-218" class="mi">t</span><span id="MathJax-Span-219" class="mi">i</span></span><span id="MathJax-Span-220" class="mo">(</span><span id="MathJax-Span-221" class="mi">X</span><span id="MathJax-Span-222" class="mo">)</span><span id="MathJax-Span-223" class="mo">=</span><span id="MathJax-Span-224" class="msubsup"><span id="MathJax-Span-225" class="mi">x</span><span id="MathJax-Span-226" class="mi">i</span></span><span id="MathJax-Span-227" class="mo">⨁</span><span id="MathJax-Span-228" class="msubsup"><span id="MathJax-Span-229" class="mi">x</span><span id="MathJax-Span-230" class="texatom"><span id="MathJax-Span-231" class="mrow"><span id="MathJax-Span-232" class="mi">i</span><span id="MathJax-Span-233" class="mo">+</span><span id="MathJax-Span-234" class="mn">1</span></span></span></span></span></span></span>. Note that the CSP has a chain structure. Implement <code>create_chain_csp()</code> by creating a generic chain CSP with XOR as factors.<strong>Note</strong>: We’ve provided you with a CSP implementation in <code><a href="util.py">util.py</a></code> which supports unary and binary factors. For now, you don’t need to understand the implementation, but please read the comments and get yourself familiar with the CSP interface. For this problem, you’ll need to use <code>CSP.add_variable()</code> and <code>CSP.add_binary_factor()</code>.</li>

</ol>

So far, we’ve only worked with unweighted CSPs, where <span id="MathJax-Element-28-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-235" class="math"><span id="MathJax-Span-236" class="mrow"><span id="MathJax-Span-237" class="msubsup"><span id="MathJax-Span-238" class="mi">f</span><span id="MathJax-Span-239" class="mi">j</span></span><span id="MathJax-Span-240" class="mo">(</span><span id="MathJax-Span-241" class="mi">x</span><span id="MathJax-Span-242" class="mo">)</span><span id="MathJax-Span-243" class="mo">∈</span><span id="MathJax-Span-244" class="mo">{</span><span id="MathJax-Span-245" class="mn">0</span><span id="MathJax-Span-246" class="mo">,</span><span id="MathJax-Span-247" class="mn">1</span><span id="MathJax-Span-248" class="mo">}</span></span></span></span>. In this problem, we will work with weighted CSPs, which associates a weight for each assignment <span id="MathJax-Element-29-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-249" class="math"><span id="MathJax-Span-250" class="mrow"><span id="MathJax-Span-251" class="mi">x</span></span></span></span> based on the product of <span id="MathJax-Element-30-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-252" class="math"><span id="MathJax-Span-253" class="mrow"><span id="MathJax-Span-254" class="mi">m</span></span></span></span> factor functions <span id="MathJax-Element-31-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-255" class="math"><span id="MathJax-Span-256" class="mrow"><span id="MathJax-Span-257" class="msubsup"><span id="MathJax-Span-258" class="mi">f</span><span id="MathJax-Span-259" class="mn">1</span></span><span id="MathJax-Span-260" class="mo">,</span><span id="MathJax-Span-261" class="mo">…</span><span id="MathJax-Span-262" class="mo">,</span><span id="MathJax-Span-263" class="msubsup"><span id="MathJax-Span-264" class="mi">f</span><span id="MathJax-Span-265" class="mi">m</span></span></span></span></span>:

where each factor <span id="MathJax-Element-33-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-287" class="math"><span id="MathJax-Span-288" class="mrow"><span id="MathJax-Span-289" class="msubsup"><span id="MathJax-Span-290" class="mi">f</span><span id="MathJax-Span-291" class="mi">j</span></span><span id="MathJax-Span-292" class="mo">(</span><span id="MathJax-Span-293" class="mi">x</span><span id="MathJax-Span-294" class="mo">)</span><span id="MathJax-Span-295" class="mo">≥</span><span id="MathJax-Span-296" class="mn">0</span></span></span></span>. Our goal is to find the assignment(s) <span id="MathJax-Element-34-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-297" class="math"><span id="MathJax-Span-298" class="mrow"><span id="MathJax-Span-299" class="mi">x</span></span></span></span> with the <em>highest</em> weight. As in problem 0, we will assume that each factor is either a unary factor (depends on exactly one variable) or a binary factor (depends on exactly two variables).

For weighted CSP construction, you can refer to the CSP examples we provided in <code><a href="util.py">util.py</a></code> for guidance (<code>create_map_coloring_csp()</code> and <code>create_weighted_csp()</code>). You can try these examples out by running

<pre>python run_p1.py</pre>

Notice we are already able to solve the CSPs, because in <code><a href="submission.py">submission.py</a></code>, a basic backtracking search is already implemented. Recall that backtracking search operates over partial assignments and associates each partial assignment with a weight, which is the product of all the factors that depend only on the assigned variables. When we assign a value to a new variable <span id="MathJax-Element-35-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-300" class="math"><span id="MathJax-Span-301" class="mrow"><span id="MathJax-Span-302" class="msubsup"><span id="MathJax-Span-303" class="mi">X</span><span id="MathJax-Span-304" class="mi">i</span></span></span></span></span>, we multiply in all the factors that depend only on <span id="MathJax-Element-36-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-305" class="math"><span id="MathJax-Span-306" class="mrow"><span id="MathJax-Span-307" class="msubsup"><span id="MathJax-Span-308" class="mi">X</span><span id="MathJax-Span-309" class="mi">i</span></span></span></span></span> and the previously assigned variables. The function <code>get_delta_weight()</code> returns the contribution of these new factors based on the <code>unaryFactors</code> and <code>binaryFactors</code>. An important case is when <code>get_delta_weight()</code> returns 0. In this case, any full assignment that extends the new partial assignment will also be zero, so <i>there is no need to search further with that new partial assignment</i>.

Take a look at <code>BacktrackingSearch.reset_results()</code> to see the other fields which are set as a result of solving the weighted CSP. You should read <code>submission.BacktrackingSearch</code> carefully to make sure that you understand how the backtracking search is working on the CSP.

<ol class="problem">

 <li id="1a" class="code">[4 points] Let’s create a CSP to solve the n-queens problem: Given an <span id="MathJax-Element-37-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-310" class="math"><span id="MathJax-Span-311" class="mrow"><span id="MathJax-Span-312" class="mi">n</span><span id="MathJax-Span-313" class="mo">×</span><span id="MathJax-Span-314" class="mi">n</span></span></span></span> board, we’d like to place <span id="MathJax-Element-38-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-315" class="math"><span id="MathJax-Span-316" class="mrow"><span id="MathJax-Span-317" class="mi">n</span></span></span></span> queens on this board such that no two queens are on the same row, column, or diagonal. Implement <code>create_nqueens_csp()</code> by <strong>adding <span id="MathJax-Element-39-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-318" class="math"><span id="MathJax-Span-319" class="mrow"><span id="MathJax-Span-320" class="mi">n</span></span></span></span> variables</strong> and some number of binary factors. Note that the solver collects some basic statistics on the performance of the algorithm. You should take advantage of these statistics for debugging and analysis. You should get 92 (optimal) assignments for <span id="MathJax-Element-40-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-321" class="math"><span id="MathJax-Span-322" class="mrow"><span id="MathJax-Span-323" class="mi">n</span><span id="MathJax-Span-324" class="mo">=</span><span id="MathJax-Span-325" class="mn">8</span></span></span></span> with exactly 2057 operations (number of calls to <code>backtrack()</code>).<p class="hint">Hint: If you get a larger number of operations, make sure your CSP is minimal. Try to define the variables such that the size of domain is O(n).<p class="hint">Note: Please implement the domain of variables as ‘list’ type in Python (again, you may refer to <code>create_map_coloring_csp()</code> and <code>create_weighted_csp()</code> in <code><a href="util.py">util.py</a></code> as examples of CSP problem implementations), so you can compare the number of operations with our suggestions as a way of debugging.</li>

 <li id="1b" class="code">[4 points] You might notice that our search algorithm explores quite a large number of states even for the <span id="MathJax-Element-41-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-326" class="math"><span id="MathJax-Span-327" class="mrow"><span id="MathJax-Span-328" class="mn">8</span><span id="MathJax-Span-329" class="mo">×</span><span id="MathJax-Span-330" class="mn">8</span></span></span></span> board. Let’s see if we can do better. One heuristic we discussed in class is using most constrained variable (MCV): To choose an unassigned variable, pick the <span id="MathJax-Element-42-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-331" class="math"><span id="MathJax-Span-332" class="mrow"><span id="MathJax-Span-333" class="msubsup"><span id="MathJax-Span-334" class="mi">X</span><span id="MathJax-Span-335" class="mi">j</span></span></span></span></span> that has the fewest number of values <span id="MathJax-Element-43-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-336" class="math"><span id="MathJax-Span-337" class="mrow"><span id="MathJax-Span-338" class="mi">a</span></span></span></span> which are consistent with the current partial assignment (<span id="MathJax-Element-44-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-339" class="math"><span id="MathJax-Span-340" class="mrow"><span id="MathJax-Span-341" class="mi">a</span></span></span></span> for which <code>get_delta_weight()</code> on <span id="MathJax-Element-45-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-342" class="math"><span id="MathJax-Span-343" class="mrow"><span id="MathJax-Span-344" class="msubsup"><span id="MathJax-Span-345" class="mi">X</span><span id="MathJax-Span-346" class="mi">j</span></span><span id="MathJax-Span-347" class="mo">=</span><span id="MathJax-Span-348" class="mi">a</span></span></span></span> returns a non-zero value). Implement this heuristic in <code>get_unassigned_variable()</code> under the condition <code>self.mcv = True</code>. It should take you exactly 1361 operations to find all optimal assignments for 8 queens CSP — that’s 30% fewer!Some useful fields:

  <ul>

   <li><code>csp.unaryFactors[var][val]</code> gives the unary factor value.</li>

   <li><code>csp.binaryFactors[var1][var2][val1][val2]</code> gives the binary factor value. Here, <code>var1</code> and <code>var2</code> are variables and <code>val1</code> and <code>val2</code> are their corresponding values.</li>

   <li>In <code>BacktrackingSearch</code>, if <code>var</code> has been assigned a value, you can retrieve it using <code>assignment[var]</code>. Otherwise <code>var</code> is not in <code>assignment</code>.</li>

  </ul></li>

 <li id="1c" class="code">[8 points] The previous heuristics looked only at the local effects of a variable or value. Let’s now implement arc consistency (AC-3) that we discussed in lecture. After we set variable <span id="MathJax-Element-46-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-349" class="math"><span id="MathJax-Span-350" class="mrow"><span id="MathJax-Span-351" class="msubsup"><span id="MathJax-Span-352" class="mi">X</span><span id="MathJax-Span-353" class="mi">j</span></span></span></span></span> to value <span id="MathJax-Element-47-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-354" class="math"><span id="MathJax-Span-355" class="mrow"><span id="MathJax-Span-356" class="mi">a</span></span></span></span>, we remove the values <span id="MathJax-Element-48-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-357" class="math"><span id="MathJax-Span-358" class="mrow"><span id="MathJax-Span-359" class="mi">b</span></span></span></span> of all neighboring variables <span id="MathJax-Element-49-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-360" class="math"><span id="MathJax-Span-361" class="mrow"><span id="MathJax-Span-362" class="msubsup"><span id="MathJax-Span-363" class="mi">X</span><span id="MathJax-Span-364" class="mi">k</span></span></span></span></span> that could cause arc-inconsistencies. If <span id="MathJax-Element-50-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-365" class="math"><span id="MathJax-Span-366" class="mrow"><span id="MathJax-Span-367" class="msubsup"><span id="MathJax-Span-368" class="mi">X</span><span id="MathJax-Span-369" class="mi">k</span></span></span></span></span>‘s domain has changed, we use <span id="MathJax-Element-51-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-370" class="math"><span id="MathJax-Span-371" class="mrow"><span id="MathJax-Span-372" class="msubsup"><span id="MathJax-Span-373" class="mi">X</span><span id="MathJax-Span-374" class="mi">k</span></span></span></span></span>‘s domain to remove values from the domains of its neighboring variables. This is repeated until no domain can be updated. Note that this may significantly reduce your branching factor, although at some cost. In <code>backtrack()</code> we’ve implemented code which copies and restores domains for you. Your job is to fill in <code>arc_consistency_check()</code>.You should make sure that your existing MCV implementation is compatible with your AC-3 algorithm as we will be using all three heuristics together during grading.With AC-3 enabled, it should take you 769 operations only to find all optimal assignments to 8 queens CSP — That is almost 45% fewer even compared with MCV!<strong>Take a deep breath! This part requires time and effort to implement — be patient.</strong><p class="hint">Hint 1: documentation for <code>CSP.add_unary_factor()</code> and <code>CSP.add_binary_factor()</code> can be helpful.Hint 2: although AC-3 works recursively, you may implement it iteratively. Using a queue might be a good idea. <code>li.pop(0)</code> removes and returns the first element for a python list <code>li</code>.</li>

</ol>

So far, our CSP solver only handles unary and binary factors, but for course scheduling (and really any non-trivial application), we would like to define factors that involve more than two variables. It would be nice if we could have a general way of reducing <span id="MathJax-Element-53-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-378" class="math"><span id="MathJax-Span-379" class="mrow"><span id="MathJax-Span-380" class="mi">n</span></span></span></span>-ary constraint to unary and binary constraints. In this problem, we will do exactly that for two types of <span id="MathJax-Element-54-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-381" class="math"><span id="MathJax-Span-382" class="mrow"><span id="MathJax-Span-383" class="mi">n</span></span></span></span>-ary constraints.

<p id="get_or_var">Suppose we have boolean variables <span id="MathJax-Element-55-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-384" class="math"><span id="MathJax-Span-385" class="mrow"><span id="MathJax-Span-386" class="msubsup"><span id="MathJax-Span-387" class="mi">X</span><span id="MathJax-Span-388" class="mn">1</span></span><span id="MathJax-Span-389" class="mo">,</span><span id="MathJax-Span-390" class="msubsup"><span id="MathJax-Span-391" class="mi">X</span><span id="MathJax-Span-392" class="mn">2</span></span><span id="MathJax-Span-393" class="mo">,</span><span id="MathJax-Span-394" class="msubsup"><span id="MathJax-Span-395" class="mi">X</span><span id="MathJax-Span-396" class="mn">3</span></span></span></span></span>, where <span id="MathJax-Element-56-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-397" class="math"><span id="MathJax-Span-398" class="mrow"><span id="MathJax-Span-399" class="msubsup"><span id="MathJax-Span-400" class="mi">X</span><span id="MathJax-Span-401" class="mi">i</span></span></span></span></span> represents whether the <span id="MathJax-Element-57-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-402" class="math"><span id="MathJax-Span-403" class="mrow"><span id="MathJax-Span-404" class="mi">i</span></span></span></span>-th course is taken. Suppose we want to enforce the constraint that <span id="MathJax-Element-58-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-405" class="math"><span id="MathJax-Span-406" class="mrow"><span id="MathJax-Span-407" class="mi">Y</span><span id="MathJax-Span-408" class="mo">=</span><span id="MathJax-Span-409" class="msubsup"><span id="MathJax-Span-410" class="mi">X</span><span id="MathJax-Span-411" class="mn">1</span></span><span id="MathJax-Span-412" class="mo">∨</span><span id="MathJax-Span-413" class="msubsup"><span id="MathJax-Span-414" class="mi">X</span><span id="MathJax-Span-415" class="mn">2</span></span><span id="MathJax-Span-416" class="mo">∨</span><span id="MathJax-Span-417" class="msubsup"><span id="MathJax-Span-418" class="mi">X</span><span id="MathJax-Span-419" class="mn">3</span></span></span></span></span>, that is, <span id="MathJax-Element-59-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-420" class="math"><span id="MathJax-Span-421" class="mrow"><span id="MathJax-Span-422" class="mi">Y</span></span></span></span> is a boolean representing whether at least one course has been taken. For reference, in <code><a href="util.py">util.py</a></code>, the function <code>get_or_variable()</code> does such a reduction. It takes in a list of variables and a target value, and returns a boolean variable with domain <code>[True, False]</code> whose value is constrained to the condition of having at least one of the variables assigned to the target value. For example, we would call <code>get_or_variable()</code> with arguments <span id="MathJax-Element-60-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-423" class="math"><span id="MathJax-Span-424" class="mrow"><span id="MathJax-Span-425" class="mo">(</span><span id="MathJax-Span-426" class="msubsup"><span id="MathJax-Span-427" class="mi">X</span><span id="MathJax-Span-428" class="mn">1</span></span><span id="MathJax-Span-429" class="mo">,</span><span id="MathJax-Span-430" class="msubsup"><span id="MathJax-Span-431" class="mi">X</span><span id="MathJax-Span-432" class="mn">2</span></span><span id="MathJax-Span-433" class="mo">,</span><span id="MathJax-Span-434" class="msubsup"><span id="MathJax-Span-435" class="mi">X</span><span id="MathJax-Span-436" class="mn">3</span></span><span id="MathJax-Span-437" class="mo">,</span><span id="MathJax-Span-438" class="mtext">True</span><span id="MathJax-Span-439" class="mo">)</span></span></span></span>, which would return a new (auxiliary) variable <span id="MathJax-Element-61-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-440" class="math"><span id="MathJax-Span-441" class="mrow"><span id="MathJax-Span-442" class="msubsup"><span id="MathJax-Span-443" class="mi">X</span><span id="MathJax-Span-444" class="mn">4</span></span></span></span></span>, and then add another constraint <span id="MathJax-Element-62-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-445" class="math"><span id="MathJax-Span-446" class="mrow"><span id="MathJax-Span-447" class="mo">[</span><span id="MathJax-Span-448" class="msubsup"><span id="MathJax-Span-449" class="mi">X</span><span id="MathJax-Span-450" class="mn">4</span></span><span id="MathJax-Span-451" class="mo">=</span><span id="MathJax-Span-452" class="mtext">True</span><span id="MathJax-Span-453" class="mo">]</span></span></span></span>.

The second type of <span id="MathJax-Element-63-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-454" class="math"><span id="MathJax-Span-455" class="mrow"><span id="MathJax-Span-456" class="mi">n</span></span></span></span>-ary factors is constraints on the sum over <span id="MathJax-Element-64-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-457" class="math"><span id="MathJax-Span-458" class="mrow"><span id="MathJax-Span-459" class="mi">n</span></span></span></span> variables. You are going to implement reduction of this type but let’s first look at a simpler problem to get started:

<ol class="problem">

 <li id="2a" class="writeup">[4 points] Suppose we have a CSP with three variables <span id="MathJax-Element-65-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-460" class="math"><span id="MathJax-Span-461" class="mrow"><span id="MathJax-Span-462" class="msubsup"><span id="MathJax-Span-463" class="mi">X</span><span id="MathJax-Span-464" class="mn">1</span></span><span id="MathJax-Span-465" class="mo">,</span><span id="MathJax-Span-466" class="msubsup"><span id="MathJax-Span-467" class="mi">X</span><span id="MathJax-Span-468" class="mn">2</span></span><span id="MathJax-Span-469" class="mo">,</span><span id="MathJax-Span-470" class="msubsup"><span id="MathJax-Span-471" class="mi">X</span><span id="MathJax-Span-472" class="mn">3</span></span></span></span></span> with the same domain <span id="MathJax-Element-66-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-473" class="math"><span id="MathJax-Span-474" class="mrow"><span id="MathJax-Span-475" class="mo">{</span><span id="MathJax-Span-476" class="mn">0</span><span id="MathJax-Span-477" class="mo">,</span><span id="MathJax-Span-478" class="mn">1</span><span id="MathJax-Span-479" class="mo">,</span><span id="MathJax-Span-480" class="mn">2</span><span id="MathJax-Span-481" class="mo">}</span></span></span></span> and a ternary constraint <span id="MathJax-Element-67-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-482" class="math"><span id="MathJax-Span-483" class="mrow"><span id="MathJax-Span-484" class="mo">[</span><span id="MathJax-Span-485" class="msubsup"><span id="MathJax-Span-486" class="mi">X</span><span id="MathJax-Span-487" class="mn">1</span></span><span id="MathJax-Span-488" class="mo">+</span><span id="MathJax-Span-489" class="msubsup"><span id="MathJax-Span-490" class="mi">X</span><span id="MathJax-Span-491" class="mn">2</span></span><span id="MathJax-Span-492" class="mo">+</span><span id="MathJax-Span-493" class="msubsup"><span id="MathJax-Span-494" class="mi">X</span><span id="MathJax-Span-495" class="mn">3</span></span><span id="MathJax-Span-496" class="mo">≤</span><span id="MathJax-Span-497" class="mi">K</span><span id="MathJax-Span-498" class="mo">]</span></span></span></span>. How can we reduce this CSP to one with only unary and/or binary constraints? Explain what auxiliary variables we need to introduce, what their domains are, what unary/binary factors you’ll add, and why your scheme works. Add a graph if you think that’ll better explain your scheme.<p class="hint">Hint: draw inspiration from the example of enforcing <span id="MathJax-Element-68-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-499" class="math"><span id="MathJax-Span-500" class="mrow"><span id="MathJax-Span-501" class="mo">[</span><span id="MathJax-Span-502" class="msubsup"><span id="MathJax-Span-503" class="mi">X</span><span id="MathJax-Span-504" class="mi">i</span></span><span id="MathJax-Span-505" class="mo">=</span><span id="MathJax-Span-506" class="mn">1</span><span id="MathJax-Span-507" class="mtext"> </span><span id="MathJax-Span-508" class="mtext">for exactly one</span><span id="MathJax-Span-509" class="mtext"> </span><span id="MathJax-Span-510" class="mi">i</span><span id="MathJax-Span-511" class="mo">]</span></span></span></span> which is in the first CSP lecture.</li>

 <li id="2b" class="code">[5 points] Now let’s do the general case in code: implement <code>get_sum_variable()</code>, which takes in a sequence of non-negative integer-valued variables and returns a variable whose value is constrained to equal the sum of the variables. You will need to access the domains of the variables passed in, which you can assume contain only non-negative integers. The parameter <code>maxSum</code> is the maximum sum possible of all the variables. You can use this information to decide the proper domains for your auxiliary variables.How can this function be useful? Suppose we wanted to enforce the constraint <span id="MathJax-Element-69-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-512" class="math"><span id="MathJax-Span-513" class="mrow"><span id="MathJax-Span-514" class="mo">[</span><span id="MathJax-Span-515" class="msubsup"><span id="MathJax-Span-516" class="mi">X</span><span id="MathJax-Span-517" class="mn">1</span></span><span id="MathJax-Span-518" class="mo">+</span><span id="MathJax-Span-519" class="msubsup"><span id="MathJax-Span-520" class="mi">X</span><span id="MathJax-Span-521" class="mn">2</span></span><span id="MathJax-Span-522" class="mo">+</span><span id="MathJax-Span-523" class="msubsup"><span id="MathJax-Span-524" class="mi">X</span><span id="MathJax-Span-525" class="mn">3</span></span><span id="MathJax-Span-526" class="mo">≤</span><span id="MathJax-Span-527" class="mi">K</span><span id="MathJax-Span-528" class="mo">]</span></span></span></span>. We would call <code>get_sum_variable()</code> on <span id="MathJax-Element-70-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-529" class="math"><span id="MathJax-Span-530" class="mrow"><span id="MathJax-Span-531" class="mo">(</span><span id="MathJax-Span-532" class="msubsup"><span id="MathJax-Span-533" class="mi">X</span><span id="MathJax-Span-534" class="mn">1</span></span><span id="MathJax-Span-535" class="mo">,</span><span id="MathJax-Span-536" class="msubsup"><span id="MathJax-Span-537" class="mi">X</span><span id="MathJax-Span-538" class="mn">2</span></span><span id="MathJax-Span-539" class="mo">,</span><span id="MathJax-Span-540" class="msubsup"><span id="MathJax-Span-541" class="mi">X</span><span id="MathJax-Span-542" class="mn">3</span></span><span id="MathJax-Span-543" class="mo">)</span></span></span></span> to get some auxiliary variable <span id="MathJax-Element-71-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-544" class="math"><span id="MathJax-Span-545" class="mrow"><span id="MathJax-Span-546" class="mi">Y</span></span></span></span>, and then add the constraint <span id="MathJax-Element-72-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-547" class="math"><span id="MathJax-Span-548" class="mrow"><span id="MathJax-Span-549" class="mo">[</span><span id="MathJax-Span-550" class="mi">Y</span><span id="MathJax-Span-551" class="mo">≤</span><span id="MathJax-Span-552" class="mi">K</span><span id="MathJax-Span-553" class="mo">]</span></span></span></span>. Note: You don’t have to implement the <span id="MathJax-Element-73-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-554" class="math"><span id="MathJax-Span-555" class="mrow"><span id="MathJax-Span-556" class="mo">≤</span></span></span></span> constraint for this part.</li>

</ol>

In this problem, we will apply your weighted CSP solver to the problem of course scheduling. We have scraped a subset of courses that are offered from Stanford’s Bulletin. For each course in this dataset, we have information on which quarters it is offered, the prerequisites (which may not be fully accurate due to ambiguity in the listing), and the range of units allowed. You can take a look at all the courses in <code>courses.json</code>. Please refer to <code>util.Course</code> and <code>util.CourseBulletin</code> for more information.

To specify a desired course plan, you would need to provide a <i>profile</i> which specifies your constraints and preferences for courses. A profile is specified in a text file (see <code>profile*.txt</code> for examples). The profile file has four sections:

<ul>

 <li>The first section specifies a fixed minimum and maximum (inclusive) number of units you need to take for each quarter. For example:<pre>minUnits 0maxUnits 3</pre></li>

 <li>In the second section, you <code>register</code> for the quarters that you want to take your courses in. For example,<pre>register Aut2017register Win2018register Spr2018</pre>would sign you up for this academic year. The quarters need not to be contiguous, but they must follow the exact format <code>XxxYYYY</code> where <code>Xxx</code> is one of <code>Aut, Win, Spr, Sum</code> and <code>YYYY</code> is the year.</li>

 <li>The third section specifies the list of courses that you’ve taken in the past and elsewhere using the <code>taken</code> keyword. For example, if you’re in CS221, this is probably what you would put:<pre>taken CS103taken CS106Btaken CS107taken CS109</pre></li>

 <li>The last section is a list of courses that you would like to take during the registered quarters, specified using <code>request</code>. For example, two basic requests would look like this:<pre>request CS224Nrequest CS229</pre>Not every request must be fulfilled, and indeed, due to the additional constraints described below, it is possible that not all of them can actually be fulfilled.</li>

</ul>

<b>Constrained requests.</b> To allow for more flexibility in your preferences, we allow some freedom to customize the requests:

<ul>

 <li>You can request to take exclusively one of several courses but not sure which one, then specify:<pre id="sample-request">request CS229 or CS229A or CS229T</pre>Note that these courses do not necessarily have to be offered in the same quarter. The final schedule can have at most one of these three courses. <b>Each course can only be requested at most once.</b></li>

 <li>If you want to take a course in one of a specified set of quarters, use the <code>in</code> modifier. For example, if you want to take one of CS221 or CS229 in either Aut2017 <b>or</b> Sum2018, do:<pre>request CS221 or CS229 in Aut2017,Sum2018</pre>If you do not specify any quarters, then the course can be taken in any quarter.</li>

 <li>Another operator you can apply is <code>after</code>, which specifies that a course must be taken after another one. For example, if you want to choose one of CS221 or CS229 and take it after both CS109 <b>and</b> CS161, add:<pre>request CS221 or CS229 after CS109,CS161</pre>Note that this implies that if you take CS221 or CS229, then you must take both CS109 and CS161. In this case, we say that CS109 and CS161 are <code>prereqs</code> of this request. (Note that there’s <strong>no space</strong> after the comma.)If you request course A and B (separately), and A is an official prerequisite of B based on the <code>CourseBulletin</code>, we will automatically add A as a prerequisite for B; that is, typing <code>request B</code> is equivalent to <code>request B after A</code>. Note that if B is a prerequisite of A, to request A, you must either request B or declare you’ve taken B before.</li>

 <li>Finally, the last operator you can add is <code>weight</code>, which adds non-negative weight to each request. All requests have a default weight value of 1. Requests with higher weight should be preferred by your CSP solver. Note that you can combine all of the aforementioned operators into one as follows (again, no space after comma):<pre id="sample-request">request CS221 or CS229 in Win2017,Win2018 after CS131 weight 5</pre></li>

</ul>

Each <code>request</code> line in your profile is represented in code as an instance of the <code>Request</code> class (see <code><a href="util.py">util.py</a></code>). For example, the request above would have the following fields:

<ul>

 <li><code>cids</code> (course IDs that you’re choosing one of) with value <code>['CS221', 'CS229']</code></li>

 <li><code>quarters</code> (that you’re allowed to take the courses) with value <code>['Win2017', 'Win2018']</code></li>

 <li><code>prereqs</code> (course IDs that you must take before) with value <code>['CS131']</code></li>

 <li><code>weight</code> (preference) with value <code>5.0</code></li>

</ul>

It’s important to note that a request does not have to be fulfilled, <em>but if it is</em>, the constraints specified by the various operators <code>after,in</code> must also be satisfied.

You shall not worry about parsing the profiles because we have done all the parsing of the bulletin and profile for you, so all you need to work with is the collection of <code>Request</code> objects in <code>Profile</code> and <code>CourseBulletin</code> to know when courses are offered and the number of units of courses.

Well, that’s a lot of information! Let’s open a python shell and see them in action:

<pre>import util# load bulletinbulletin = util.CourseBulletin('courses.json')# retrieve information of CS221cs221 = bulletin.courses['CS221']print cs221# look at various properties of the courseprint cs221.cidprint cs221.minUnitsprint cs221.maxUnitsprint cs221.prereqs  # the prerequisitesprint cs221.is_offered_in('Aut2017')print cs221.is_offered_in('Win2018')# load profile from profile_example.txtprofile = util.Profile(bulletin, 'profile_example.txt')# see what it's aboutprofile.print_info()# iterate over the requests and print out the propertiesfor request in profile.requests:    print request.cids, request.quarters, request.prereqs, request.weight</pre>

<b>Solving the CSP.</b> Your task is to take a profile and bulletin and construct a CSP. We have started you off with code in <code>SchedulingCSPConstructor</code> that constructs the core variables of the CSP as well as some basic constraints. The variables are all pairs of requests and registered quarters <code>(request, quarter)</code>, and the value of such a variable is one of the course IDs in that Request or <code>None</code>, which indicates none of the courses should be taken in that quarter. We will add auxiliary variables later. We have also implemented some basic constraints: <code>add_bulletin_constraints()</code>, which enforces that a course can only be taken if it’s offered in that quarter (according to the bulletin), and <code>add_norepeating_contstraints()</code>, which constrains that no course can be taken more than once.

You should take a look at <code>add_bulletin_constraints()</code> and <code>add_norepeating_contstraints()</code> to get a basic understanding how the CSP for scheduling is represented. Nevertheless, we’ll highlight some important details to make it easier for you to implement:

<ul class="alert">

 <li>The existing variables are tuples of <code>(request, quarter)</code> where <code>request</code> is a <code>Request</code> object (like <a href="#sample-request">the one shown above</a>) and <code>quarter</code> is a <code>str</code> representing a quarter (e.g. <code>'Aut2017'</code>). For detail please look at <code>SchedulingCSPConstructor.add_variables()</code>.</li>

 <li>The domain of each variable <code>(request, quarter)</code> is the course IDs of the request <strong>plus</strong> <code>None</code> (e.g. <code>['CS221', 'CS229', None]</code>). When the value <code>cid</code> is <code>None</code>, this means no course is scheduled for this request. <strong>Always remember to check if <code>cid</code> is <code>None</code></strong>.</li>

 <li>The domain for <code>quarter</code> is all possible quarters (<code>self.profile.quarters</code>, e.g. <code>['Win2016', 'Win2017']</code>).</li>

 <li>Given a course ID <code>cid</code>, you can get the corresponding <code>Course</code> object by <code>self.bulletin.courses[cid]</code>.</li>

</ul>

<ol class="problem">

 <li id="3a" class="code">[5 points] Implement the <code>add_quarter_constraints()</code>. This is when your profile specifies which quarter(s) you want your requested courses to be taken in. This is not saying that one of the courses must be taken, <em>but if it is</em>, then it must be taken in any one of the specified quarters. Also note that this constraint will apply to all courses in that request.We have written a <code>verify_schedule()</code> function in <code><a href="grader.py">grader.py</a></code> that determines if your schedule satisfies all of the given constraints. Note that since we are not dealing with units yet, it will print <code>None</code> for the number of units of each course. For profile3a.txt, you should find 3 optimal assignments with weight 1.0.</li>

 <li id="3b" class="code">[9 points] Let’s now add the unit constraints in <code>add_unit_constraints()</code>. (1) You must ensure that the sum of units per quarter for your schedule are within the min and max threshold inclusive. You should use <code>get_sum_variable()</code>. (2) In order for our solution extractor to obtain the number of units, for every course, you must add a variable <code>(courseId, quarter)</code> to the CSP taking on a value equal to the number of units being taken for that course during that quarter. When the course is not taken during that quarter, the unit should be 0. <b>NOTE:</b> Each grader test only tests the function you are asked to implement. To test your CSP with multiple constraints you can use <code><a href="run_p3.py">run_p3.py</a></code> and changing the constraints that you want to add. For profile3b.txt, you should find 15 optimal assignments with weight 1.0.<p class="hint">Hint: If your code times out, your <code>maxSum</code> passed to <code>get_sum_variable()</code> might be too large.</li>

 <li id="3c" class="writeup">[2 points] Now try to use the course scheduler for the winter and spring (and next year if applicable). Create your own <code>profile.txt</code> and then run the course scheduler:<pre>python run_p3.py profile.txt</pre>You might want to turn on the appropriate heuristic flags to speed up the computation. Does it produce a reasonable course schedule? Please include your <code>profile.txt</code> and the best schedule in your writeup; we’re curious how it worked out for you!</li>

</ol>




Want more challenges about CSP? Here we go. &#x1f600;

Suppose we have a weighted CSP with variables <span id="MathJax-Element-74-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-557" class="math"><span id="MathJax-Span-558" class="mrow"><span id="MathJax-Span-559" class="msubsup"><span id="MathJax-Span-560" class="mi">X</span><span id="MathJax-Span-561" class="mn">1</span></span><span id="MathJax-Span-562" class="mo">,</span><span id="MathJax-Span-563" class="mo">…</span><span id="MathJax-Span-564" class="mo">,</span><span id="MathJax-Span-565" class="msubsup"><span id="MathJax-Span-566" class="mi">X</span><span id="MathJax-Span-567" class="mi">n</span></span></span></span></span> with domains <span id="MathJax-Element-75-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-568" class="math"><span id="MathJax-Span-569" class="mrow"><span id="MathJax-Span-570" class="msubsup"><span id="MathJax-Span-571" class="mtext">Domain</span><span id="MathJax-Span-572" class="mi">i</span></span><span id="MathJax-Span-573" class="mo">=</span><span id="MathJax-Span-574" class="mo">{</span><span id="MathJax-Span-575" class="mn">1</span><span id="MathJax-Span-576" class="mo">,</span><span id="MathJax-Span-577" class="mo">…</span><span id="MathJax-Span-578" class="mo">,</span><span id="MathJax-Span-579" class="mi">K</span><span id="MathJax-Span-580" class="mo">}</span></span></span></span>. We have a set of basic factors which depend only on adjacent pairs of variables in the same way: there is some function <span id="MathJax-Element-76-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-581" class="math"><span id="MathJax-Span-582" class="mrow"><span id="MathJax-Span-583" class="mi">g</span></span></span></span> such that <span id="MathJax-Element-77-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-584" class="math"><span id="MathJax-Span-585" class="mrow"><span id="MathJax-Span-586" class="msubsup"><span id="MathJax-Span-587" class="mi">f</span><span id="MathJax-Span-588" class="mi">i</span></span><span id="MathJax-Span-589" class="mo">(</span><span id="MathJax-Span-590" class="mi">x</span><span id="MathJax-Span-591" class="mo">)</span><span id="MathJax-Span-592" class="mo">=</span><span id="MathJax-Span-593" class="mi">g</span><span id="MathJax-Span-594" class="mo">(</span><span id="MathJax-Span-595" class="msubsup"><span id="MathJax-Span-596" class="mi">x</span><span id="MathJax-Span-597" class="mi">i</span></span><span id="MathJax-Span-598" class="mo">,</span><span id="MathJax-Span-599" class="msubsup"><span id="MathJax-Span-600" class="mi">x</span><span id="MathJax-Span-601" class="texatom"><span id="MathJax-Span-602" class="mrow"><span id="MathJax-Span-603" class="mi">i</span><span id="MathJax-Span-604" class="mo">+</span><span id="MathJax-Span-605" class="mn">1</span></span></span></span><span id="MathJax-Span-606" class="mo">)</span></span></span></span> for <span id="MathJax-Element-78-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-607" class="math"><span id="MathJax-Span-608" class="mrow"><span id="MathJax-Span-609" class="mi">i</span><span id="MathJax-Span-610" class="mo">=</span><span id="MathJax-Span-611" class="mn">1</span><span id="MathJax-Span-612" class="mo">,</span><span id="MathJax-Span-613" class="mo">…</span><span id="MathJax-Span-614" class="mo">,</span><span id="MathJax-Span-615" class="mi">n</span><span id="MathJax-Span-616" class="mo">−</span><span id="MathJax-Span-617" class="mn">1</span></span></span></span>. In addition, we have a small set of <i>notable patterns</i> <span id="MathJax-Element-79-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-618" class="math"><span id="MathJax-Span-619" class="mrow"><span id="MathJax-Span-620" class="mi">P</span></span></span></span>, where each <span id="MathJax-Element-80-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-621" class="math"><span id="MathJax-Span-622" class="mrow"><span id="MathJax-Span-623" class="mi">p</span><span id="MathJax-Span-624" class="mo">∈</span><span id="MathJax-Span-625" class="mi">P</span></span></span></span> is a sequence of elements from the domain.

Let <span id="MathJax-Element-81-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-626" class="math"><span id="MathJax-Span-627" class="mrow"><span id="MathJax-Span-628" class="msubsup"><span id="MathJax-Span-629" class="mi">n</span><span id="MathJax-Span-630" class="mi">p</span></span></span></span></span> be the number of times that <span id="MathJax-Element-82-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-631" class="math"><span id="MathJax-Span-632" class="mrow"><span id="MathJax-Span-633" class="mi">p</span></span></span></span> occurs in an assignment <span id="MathJax-Element-83-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-634" class="math"><span id="MathJax-Span-635" class="mrow"><span id="MathJax-Span-636" class="mi">x</span><span id="MathJax-Span-637" class="mo">=</span><span id="MathJax-Span-638" class="mo">(</span><span id="MathJax-Span-639" class="msubsup"><span id="MathJax-Span-640" class="mi">x</span><span id="MathJax-Span-641" class="mn">1</span></span><span id="MathJax-Span-642" class="mo">,</span><span id="MathJax-Span-643" class="mo">…</span><span id="MathJax-Span-644" class="mo">,</span><span id="MathJax-Span-645" class="msubsup"><span id="MathJax-Span-646" class="mi">x</span><span id="MathJax-Span-647" class="mi">n</span></span><span id="MathJax-Span-648" class="mo">)</span></span></span></span> as a consecutive sequence. Define the weight of an assignment <span id="MathJax-Element-84-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-649" class="math"><span id="MathJax-Span-650" class="mrow"><span id="MathJax-Span-651" class="mi">x</span></span></span></span> to be <span id="MathJax-Element-85-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-652" class="math"><span id="MathJax-Span-653" class="mrow"><span id="MathJax-Span-654" class="mstyle"><span id="MathJax-Span-655" class="mrow"><span id="MathJax-Span-656" class="munderover"><span id="MathJax-Span-657" class="mo">∏</span><span id="MathJax-Span-658" class="texatom"><span id="MathJax-Span-659" class="mrow"><span id="MathJax-Span-660" class="mi">i</span><span id="MathJax-Span-661" class="mo">=</span><span id="MathJax-Span-662" class="mn">1</span></span></span><span id="MathJax-Span-663" class="texatom"><span id="MathJax-Span-664" class="mrow"><span id="MathJax-Span-665" class="mi">n</span><span id="MathJax-Span-666" class="mo">−</span><span id="MathJax-Span-667" class="mn">1</span></span></span></span><span id="MathJax-Span-668" class="msubsup"><span id="MathJax-Span-669" class="mi">f</span><span id="MathJax-Span-670" class="mi">i</span></span><span id="MathJax-Span-671" class="mo">(</span><span id="MathJax-Span-672" class="mi">x</span><span id="MathJax-Span-673" class="mo">)</span><span id="MathJax-Span-674" class="munderover"><span id="MathJax-Span-675" class="mo">∏</span><span id="MathJax-Span-676" class="texatom"><span id="MathJax-Span-677" class="mrow"><span id="MathJax-Span-678" class="mi">p</span><span id="MathJax-Span-679" class="mo">∈</span><span id="MathJax-Span-680" class="mi">P</span></span></span></span><span id="MathJax-Span-681" class="msubsup"><span id="MathJax-Span-682" class="mi">γ</span><span id="MathJax-Span-683" class="texatom"><span id="MathJax-Span-684" class="mrow"><span id="MathJax-Span-685" class="msubsup"><span id="MathJax-Span-686" class="mi">n</span><span id="MathJax-Span-687" class="mi">p</span></span></span></span></span><span id="MathJax-Span-688" class="mo">.</span></span></span></span></span></span> Intuitively, we multiply the weight by <span id="MathJax-Element-86-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-689" class="math"><span id="MathJax-Span-690" class="mrow"><span id="MathJax-Span-691" class="mi">γ</span></span></span></span> every time a notable pattern appears.

For example, suppose <span id="MathJax-Element-87-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-692" class="math"><span id="MathJax-Span-693" class="mrow"><span id="MathJax-Span-694" class="mi">n</span><span id="MathJax-Span-695" class="mo">=</span><span id="MathJax-Span-696" class="mn">4</span></span></span></span>, <span id="MathJax-Element-88-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-697" class="math"><span id="MathJax-Span-698" class="mrow"><span id="MathJax-Span-699" class="mi">γ</span><span id="MathJax-Span-700" class="mo">=</span><span id="MathJax-Span-701" class="mn">7</span></span></span></span>, <span id="MathJax-Element-89-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-702" class="math"><span id="MathJax-Span-703" class="mrow"><span id="MathJax-Span-704" class="mi">g</span><span id="MathJax-Span-705" class="mo">(</span><span id="MathJax-Span-706" class="mi">a</span><span id="MathJax-Span-707" class="mo">,</span><span id="MathJax-Span-708" class="mi">b</span><span id="MathJax-Span-709" class="mo">)</span><span id="MathJax-Span-710" class="mo">=</span><span id="MathJax-Span-711" class="mn">5</span><span id="MathJax-Span-712" class="mo">[</span><span id="MathJax-Span-713" class="mi">a</span><span id="MathJax-Span-714" class="mo">=</span><span id="MathJax-Span-715" class="mi">b</span><span id="MathJax-Span-716" class="mo">]</span><span id="MathJax-Span-717" class="mo">+</span><span id="MathJax-Span-718" class="mn">1</span><span id="MathJax-Span-719" class="mo">[</span><span id="MathJax-Span-720" class="mi">a</span><span id="MathJax-Span-721" class="mo">≠</span><span id="MathJax-Span-722" class="mi">b</span><span id="MathJax-Span-723" class="mo">]</span></span></span></span> and <span id="MathJax-Element-90-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-724" class="math"><span id="MathJax-Span-725" class="mrow"><span id="MathJax-Span-726" class="mi">P</span><span id="MathJax-Span-727" class="mo">=</span><span id="MathJax-Span-728" class="mo">{</span><span id="MathJax-Span-729" class="mo">[</span><span id="MathJax-Span-730" class="mn">1</span><span id="MathJax-Span-731" class="mo">,</span><span id="MathJax-Span-732" class="mn">3</span><span id="MathJax-Span-733" class="mo">,</span><span id="MathJax-Span-734" class="mn">3</span><span id="MathJax-Span-735" class="mo">]</span><span id="MathJax-Span-736" class="mo">,</span><span id="MathJax-Span-737" class="mo">[</span><span id="MathJax-Span-738" class="mn">1</span><span id="MathJax-Span-739" class="mo">,</span><span id="MathJax-Span-740" class="mn">2</span><span id="MathJax-Span-741" class="mo">,</span><span id="MathJax-Span-742" class="mn">3</span><span id="MathJax-Span-743" class="mo">]</span><span id="MathJax-Span-744" class="mo">}</span></span></span></span>. Then the assignment <span id="MathJax-Element-91-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-745" class="math"><span id="MathJax-Span-746" class="mrow"><span id="MathJax-Span-747" class="mi">x</span><span id="MathJax-Span-748" class="mo">=</span><span id="MathJax-Span-749" class="mo">[</span><span id="MathJax-Span-750" class="mn">1</span><span id="MathJax-Span-751" class="mo">,</span><span id="MathJax-Span-752" class="mn">3</span><span id="MathJax-Span-753" class="mo">,</span><span id="MathJax-Span-754" class="mn">3</span><span id="MathJax-Span-755" class="mo">,</span><span id="MathJax-Span-756" class="mn">2</span><span id="MathJax-Span-757" class="mo">]</span></span></span></span> has weight <span id="MathJax-Element-92-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-758" class="math"><span id="MathJax-Span-759" class="mrow"><span id="MathJax-Span-760" class="mo">(</span><span id="MathJax-Span-761" class="mn">1</span><span id="MathJax-Span-762" class="mo">⋅</span><span id="MathJax-Span-763" class="mn">5</span><span id="MathJax-Span-764" class="mo">⋅</span><span id="MathJax-Span-765" class="mn">1</span><span id="MathJax-Span-766" class="mo">)</span><span id="MathJax-Span-767" class="mo">⋅</span><span id="MathJax-Span-768" class="mo">(</span><span id="MathJax-Span-769" class="msubsup"><span id="MathJax-Span-770" class="mn">7</span><span id="MathJax-Span-771" class="mn">1</span></span><span id="MathJax-Span-772" class="mo">⋅</span><span id="MathJax-Span-773" class="msubsup"><span id="MathJax-Span-774" class="mn">7</span><span id="MathJax-Span-775" class="mn">0</span></span><span id="MathJax-Span-776" class="mo">)</span><span id="MathJax-Span-777" class="mo">=</span><span id="MathJax-Span-778" class="mn">35</span></span></span></span>.

<ol class="problem">

 <li id="4a" class="writeup">[2 points] If we were to include the notable patterns as factors into the CSP, what would be the worst case treewidth? (You can assume each <span id="MathJax-Element-93-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-779" class="math"><span id="MathJax-Span-780" class="mrow"><span id="MathJax-Span-781" class="mi">p</span></span></span></span> has a maximum length of <span id="MathJax-Element-94-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-782" class="math"><span id="MathJax-Span-783" class="mrow"><span id="MathJax-Span-784" class="mi">n</span></span></span></span>.)</li>

 <li id="4b" class="writeup">[6 points] The treewidth doesn’t really tell us the true complexity of the problem. Devise an efficient algorithm to compute the maximum weight assignment. You need to describe your algorithm in enough detail but don’t need to implement it. Analyze your algorithm’s time and space complexities. You’ll get points only if your algorithm is much better than the naive solution.</li>

</ol>

5/5 - (1 vote)

This (and every) assignment has a written part and a programming part.

The full assignment with our supporting code and scripts can be downloaded as <a href="../scheduling.zip">scheduling.zip</a>.

<ol class="problem">

 <li class="writeup template">This icon means a written answer is expected in <code>scheduling.pdf</code>.</li>

 <li class="code template">This icon means you should write code in <code><a href="submission.py">submission.py</a></code>.</li>

</ol>

You should modify the code in <code><a href="submission.py">submission.py</a></code> between

<pre># BEGIN_YOUR_CODE</pre>

and

<pre># END_YOUR_CODE</pre>

but you can add other helper functions outside this block if you want. Do not make changes to files other than <code><a href="submission.py">submission.py</a></code>.Your code will be evaluated on two types of test cases, <b>basic</b> and <b>hidden</b>, which you can see in <code><a href="grader.py">grader.py</a></code>. Basic tests, which are fully provided to you, do not stress your code with large inputs or tricky corner cases. Hidden tests are more complex and do stress your code. The inputs of hidden tests are provided in <code><a href="grader.py">grader.py</a></code>, but the correct outputs are not. To run the tests, you will need to have <code><a href="graderUtil.py">graderUtil.py</a></code> in the same directory as your code and <code><a href="grader.py">grader.py</a></code>. Then, you can run all the tests by typing

<pre>python grader.py</pre>

This will tell you only whether you passed the basic tests. On the hidden tests, the script will alert you if your code takes too long or crashes, but does not say whether you got the correct output. You can also run a single test (e.g., <code>3a-0-basic</code>) by typing

<pre>python grader.py 3a-0-basic</pre>

We strongly encourage you to read and understand the test cases, create your own test cases, and not just blindly run <code><a href="grader.py">grader.py</a></code>.

<hr>

<b></b>General Instructions

Problem 0: Warmup

Problem 1: CSP solving

<span id="MathJax-Element-32-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-266" class="math"><span id="MathJax-Span-267" class="mrow"><span id="MathJax-Span-268" class="mtext">Weight</span><span id="MathJax-Span-269" class="mo">(</span><span id="MathJax-Span-270" class="mi">x</span><span id="MathJax-Span-271" class="mo">)</span><span id="MathJax-Span-272" class="mo">=</span><span id="MathJax-Span-273" class="munderover"><span id="MathJax-Span-274" class="mo">∏</span><span id="MathJax-Span-275" class="texatom"><span id="MathJax-Span-276" class="mrow"><span id="MathJax-Span-277" class="mi">j</span><span id="MathJax-Span-278" class="mo">=</span><span id="MathJax-Span-279" class="mn">1</span></span></span><span id="MathJax-Span-280" class="mi">m</span></span><span id="MathJax-Span-281" class="msubsup"><span id="MathJax-Span-282" class="mi">f</span><span id="MathJax-Span-283" class="mi">j</span></span><span id="MathJax-Span-284" class="mo">(</span><span id="MathJax-Span-285" class="mi">x</span><span id="MathJax-Span-286" class="mo">)</span></span></span></span>

Problem 2: Handling <span id="MathJax-Element-52-Frame" class="MathJax" tabindex="0"><span id="MathJax-Span-375" class="math"><span id="MathJax-Span-376" class="mrow"><span id="MathJax-Span-377" class="mi">n</span></span></span></span>-ary factors

Problem 3: Course Scheduling